# Bug reproduction with `autosquash`

This repo is in a state that allows for easily reproducing a bug in `git` that occurs in a somewhat mysterious circumstance involving fixup commits and `--autosquash`.

To reproduce the bug first acquire the repo and its three branches:

```bash
git clone https://github.com/pganssle-bug-mwes/git_autosquash_bug_mwe.git
cd git_autosquash_bug_mwe
git pull --all
```

Then check out the `documentation` branch, and attempt to interactively rebase it with `--autosquash` onto the `newbase` branch. You should see the segfault, and be left in a rebasing state:

```
$ git --version
git version 2.26.2
$ git checkout documentation
$ git rebase -i --autosquash newbase
malloc(): invalid next size (unsorted)
Aborted (core dumped)
$ git status
On branch documentation
Your branch is up to date with 'origin/documentation'.

git-rebase-todo is missing.
No commands done.
No commands remaining.
You are currently editing a commit while rebasing branch 'documentation' on '1f770cf'.
  (use "git commit --amend" to amend the current commit)
  (use "git rebase --continue" once you are satisfied with your changes)

nothing to commit, working tree clean
```

Interestingly, if you attempt to rebase against `master`, the result is the same but the error is different:

```
$ git rebase -i --autosquash master
double free or corruption (out)
Aborted (core dumped)
```

The same result is obtained even if `master` and `newbase` refer to the same commit.

## Further context

The original context that this came up in had a large number of fixup commits generated by [`git absorb`](https://github.com/tummychow/git-absorb), some before the latest commit in `documentation` and some after. The offending commit has an unusual fixup message, referring to an explicit commit hash instead of the commit message:

```
$ git log --oneline master..HEAD
6c6a5a2 (HEAD -> documentation, origin/documentation) fixup! 3747813a8df9675a7c8b33c4fc665adc52d86b5b
64ebca8 fixup! Add minimal documentation for the ZoneInfo module
3747813 fixup! Add minimal documentation for the ZoneInfo module
d25a6ae fixup! Add sphinx configuration
04bac75 fixup! Add sphinx configuration
ba18026 fixup! Add sphinx configuration
a5f6347 fixup! Add minimal documentation for the ZoneInfo module
bc28c93 Add minimal documentation for the ZoneInfo module
1203b9a Add tox environment for building docs
f4af993 Add sphinx configuration
```

I found that I could still reproduce the bug if I remove everything *after* this commit (6c6a5a2), and I could remove anything *between* the commit it refers to (3747813) and the offending commit *except one* (I don't think it matters which one, just has to be at least one commit between the one it's a fixup for and the commit). If I remove anything before the one it's a fixup for, it changes the target's hash and that prevents the bug from happening.

I will note that I believe `git absorb` generates these weird commits if your feature branch gets too long â€”  it only looks at 10 or so commits for the purposes of absorbing the changes into earlier commits, so if you have say 12 commits since master, if commit 4 is a fixup for commit 1 that hits the same line as what you are currently trying to absorb, it will see commit 4 and *not* commit 1, and generate one of these weird "this is a fixup for commit 4" commits that I think is causing the problem.

Unfortunately, I haven't succeeded in creating a more minimal reproducer.
